<?php

/**
 * @file
 * Contains Document Store code.
 */

use Drupal\Component\Uuid\Uuid;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\taxonomy\Entity\Vocabulary;
use Drupal\search_api\Entity\Index;
use Drupal\search_api\Item\Field;
use Drupal\user\Entity\User;
use Symfony\Component\Yaml\Yaml;

/**
 * Implements hook_form_FORM_ID_alter().
 */
function docstore_form_field_ui_field_storage_add_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Remove the unnecessary field_ prefix.
  $language = \Drupal::languageManager()->getCurrentLanguage();
  $form['new_storage_wrapper']['field_name']['#field_prefix'] = '<span dir="' . $language->getDirection() . '">';

  // Attach validate function to prevent adding the field_ prefix.
  $form['#validate'][] = 'docstore_form_field_ui_field_overview_form_remove_field_prefix';

  // Increase maximum characters to 32 as per database constraint.
  $form['new_storage_wrapper']['field_name']['#maxlength'] = 32;
}

/**
 * Validate function to prevent adding the field_ prefix.
 */
function docstore_form_field_ui_field_overview_form_remove_field_prefix(&$form, FormStateInterface $form_state) {
  $field_name = preg_replace('/^field_/', '', $form_state->getValue('field_name'));
  $form_state->setValue('field_name', $field_name);
}

/**
 * Allowed field types and mapping to search API.
 */
function docstore_allowed_field_types() {
  // TODO Add date field.
  return [
    'string' => 'string',
    'entity_reference' => 'integer',
    'entity_reference_uuid' => 'string',
    'email' => 'string',
    'timestamp' => 'date',
    'integer' => 'integer',
    'string_long' => 'text',
  ];
}

/**
 * Create a document field for a provider.
 */
function docstore_create_document_field_for_provider($label, $field_type, $multiple = FALSE, $provider_prefix = 'shared_') {
  // Check field types.
  $allowed_types = docstore_allowed_field_types();
  if (!isset($allowed_types[$field_type])) {
    return;
  }

  // Create new machine name.
  $field_name = docstore_generate_unique_machine_name($label, 'node', $provider_prefix);

  // Create storage.
  $field_storage = FieldStorageConfig::create([
    'field_name' => $field_name,
    'entity_type' => 'node',
    'type' => $field_type,
    'cardinality' => $multiple ? FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED : 1,
  ]);
  $field_storage->save();

  // Create instance.
  FieldConfig::create([
    'field_storage' => $field_storage,
    'bundle' => 'document',
    'label' => $label,
  ])->save();

  // Add to index.
  docstore_add_document_field_to_index($field_name, $field_type, $label);

  return $field_name;
}

/**
 * Create a reference field on a document for a provider.
 */
function docstore_create_document_reference_field_for_provider($label, $bundle, $multiple = FALSE, $provider_prefix = 'shared_') {
  $field_type = 'entity_reference_uuid';
  $field_name = docstore_generate_unique_machine_name($label, 'node', $provider_prefix);
  $field_storage = FieldStorageConfig::create([
    'field_name' => $field_name,
    'entity_type' => 'node',
    'type' => $field_type,
    'cardinality' => $multiple ? FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED : 1,
    'settings' => [
      'target_type' => 'taxonomy_term',
    ],
  ]);
  $field_storage->save();

  // Create instance.
  FieldConfig::create([
    'field_storage' => $field_storage,
    'bundle' => 'document',
    'label' => $label,
    'settings' => [
      'handler' => 'default:taxonomy_term',
      'handler_settings' => [
        'target_bundles' => [
          $bundle => $bundle,
        ],
      ],
    ],
  ])->save();

  // Add to index.
  docstore_add_document_field_to_index($field_name, $field_type, $label);

  return $field_name;
}

/**
 * Add field to index.
 */
function docstore_add_document_field_to_index($field_name, $field_type, $label) {
  $field_type_mapping = docstore_allowed_field_types();

  // Skip unknown field types.
  if (!isset($field_type_mapping[$field_type])) {
    return;
  }

  $index = Index::load('documents');

  $field = new Field($index, $field_name);
  $field->setType($field_type_mapping[$field_type]);
  $field->setPropertyPath($field_name);
  $field->setDatasourceId('entity:node');
  $field->setLabel($label);
  $index->addField($field);

  // Add term name if needed.
  if ($field_type == 'entity_reference' || $field_type == 'entity_reference_uuid') {
    $field = new Field($index, $field_name . '_label');
    $field->setType('string');
    $field->setPropertyPath($field_name . ':entity:name');
    $field->setDatasourceId('entity:node');
    $field->setLabel($label . ' (name)');
    $index->addField($field);
  }

  // Save.
  $index->save();

  // Re-index.
  $index->reindex();
}

/**
 * Check is a vocabulary does exist.
 */
function docstore_vocabulary_is_valid($machine_name, $provider_prefix) {
  if (Uuid::isValid($machine_name)) {
    $vocabulary = \Drupal::service('entity.repository')->loadEntityByUuid('taxonomy_vocabulary', $machine_name);
  }
  else {
    // Assume it's the machine name.
    $vocabulary = Vocabulary::load($machine_name);
    if (!$vocabulary) {
      return FALSE;
    }
  }

  // Disallow access to base vocabularies.
  if (strpos($machine_name, 'base_') === 0) {
    return FALSE;
  }

  // Disallow access to vocabulary of an other provider.
  if (strpos($machine_name, 'shared_') !== 0 && strpos($machine_name, $provider_prefix) !== 0) {
    return FALSE;
  }

  // Check name.
  return docstore_machine_name_exists($machine_name, 'taxonomy_vocabulary');
}

/**
 * Create a vocabulary for a provider.
 */
function docstore_create_vocabulary_for_provider($label, $provider_prefix = 'shared_') {
  $vid = docstore_generate_unique_machine_name($label, 'taxonomy_vocabulary', $provider_prefix);

  $vocabulary = Vocabulary::create([
    'vid' => $vid,
    'machine_name' => $vid,
    'name' => $label,
  ]);

  $vocabulary->save();

  return $vid;
}

/**
 * Add created field to a vocabulary.
 */
function docstore_create_vocabulary_base_field_created($bundle) {
  $label = 'Created';
  $field_name = 'created';
  $field_type = 'timestamp';

  $field_storage = FieldStorageConfig::load('taxonomy_term.' . $field_name);
  if (!$field_storage) {
    $field_storage = FieldStorageConfig::create([
      'field_name' => $field_name,
      'entity_type' => 'taxonomy_term',
      'type' => $field_type,
      'cardinality' => 1,
    ]);
    $field_storage->save();
  }

  // Create instance.
  FieldConfig::create([
    'field_storage' => $field_storage,
    'bundle' => $bundle,
    'label' => $label,
  ])->save();
}

/**
 * Add provider uuid field to a vocabulary.
 */
function docstore_create_vocabulary_base_field_provider_uuid($bundle) {
  $label = 'Provider UUID';
  $field_name = 'base_provider_uuid';
  $field_type = 'entity_reference_uuid';

  $field_storage = FieldStorageConfig::load('taxonomy_term.' . $field_name);
  if (!$field_storage) {
    // Create storage.
    $field_storage = FieldStorageConfig::create([
      'field_name' => $field_name,
      'entity_type' => 'taxonomy_term',
      'type' => $field_type,
      'cardinality' => 1,
      'settings' => [
        'target_type' => 'user',
      ],
    ]);
    $field_storage->save();
  }

  // Create instance.
  FieldConfig::create([
    'field_storage' => $field_storage,
    'bundle' => $bundle,
    'label' => $label,
    'settings' => [
      'handler' => 'default:user',
      'handler_settings' => [
        'target_bundles' => [
          'provider' => 'provider',
        ],
      ],
    ],
  ])->save();
}

/**
 * Add HID id field to a vocabulary.
 */
function docstore_create_vocabulary_base_field_hid_id($bundle) {
  $label = 'Author (HID)';
  $field_name = 'base_author_hid';
  $field_type = 'string';

  $field_storage = FieldStorageConfig::load('taxonomy_term.' . $field_name);
  if (!$field_storage) {
    // Create storage.
    $field_storage = FieldStorageConfig::create([
      'field_name' => $field_name,
      'entity_type' => 'taxonomy_term',
      'type' => $field_type,
      'cardinality' => 1,
    ]);
    $field_storage->save();
  }

  // Create instance.
  FieldConfig::create([
    'field_storage' => $field_storage,
    'bundle' => $bundle,
    'label' => $label,
  ])->save();
}

/**
 * Create a vocabulary field for a provider.
 */
function docstore_create_vocabulary_field_for_provider($bundle, $label, $field_type, $multiple = FALSE, $provider_prefix = 'shared_') {
  $provider_prefix = $bundle . '_';
  $field_name = docstore_generate_unique_machine_name($label, 'taxonomy_term', $provider_prefix);

  // Create storage.
  $field_storage = FieldStorageConfig::create([
    'field_name' => $field_name,
    'entity_type' => 'taxonomy_term',
    'type' => $field_type,
    'cardinality' => $multiple ? FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED : 1,
  ]);
  $field_storage->save();

  // Create instance.
  FieldConfig::create([
    'field_storage' => $field_storage,
    'bundle' => $bundle,
    'label' => $label,
  ])->save();

  return $field_name;
}

/**
 * Create a reference field on a vocabulary for a provider.
 */
function docstore_create_vocabulary_reference_field_for_provider($bundle, $label, $target, $multiple = FALSE, $provider_prefix = 'shared_') {
  $field_type = 'entity_reference_uuid';
  $provider_prefix = $bundle . '_';
  $field_name = docstore_generate_unique_machine_name($label, 'taxonomy_term', $provider_prefix);

  // Create storage.
  $field_storage = FieldStorageConfig::create([
    'field_name' => $field_name,
    'entity_type' => 'taxonomy_term',
    'type' => $field_type,
    'cardinality' => $multiple ? FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED : 1,
    'settings' => [
      'target_type' => 'taxonomy_term',
    ],
  ]);
  $field_storage->save();

  // Create instance.
  FieldConfig::create([
    'field_storage' => $field_storage,
    'bundle' => $bundle,
    'label' => $label,
    'settings' => [
      'handler' => 'default:taxonomy_term',
      'handler_settings' => [
        'target_bundles' => [
          $target => $target,
        ],
      ],
    ],
  ])->save();

  return $field_name;
}

/**
 * Generate a unique machine name.
 */
function docstore_generate_unique_machine_name($label, $entity_type, $provider_prefix) {
  $label = strtolower($label);
  $label = preg_replace('/[^a-z0-9_]+/', '_', $label);
  $label = preg_replace('/_+/', '_', $label);
  $label = $provider_prefix . $label;

  $label = trim(substr($label, 0, 31), '_');
  $counter = 0;
  $machine_name = $label;
  while (docstore_machine_name_exists($machine_name, $entity_type)) {
    $suffix = '_' . $counter++;
    $machine_name = substr($label, 0, 31 - strlen($suffix)) . $suffix;
  }
  return $machine_name;
}

/**
 * Check if a machine name already exists.
 */
function docstore_machine_name_exists($machine_name, $entity_type) {
  if ($entity_type == 'taxonomy_vocabulary') {
    $vocabulary = Vocabulary::load($machine_name);
    return !empty($vocabulary);
  }

  $field = FieldStorageConfig::loadByName($entity_type, $machine_name);

  return !empty($field);
}

/**
 * Setup testing.
 */
function _docstore_setup_testing() {
  // Delete all documents.
  $documents = \Drupal::entityTypeManager()->getStorage('node')->loadByProperties(['type' => 'document']);
  \Drupal::entityTypeManager()->getStorage('node')->delete($documents);

  // Delete all terms.
  $terms = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->loadMultiple();
  \Drupal::entityTypeManager()->getStorage('taxonomy_term')->delete($terms);

  // Delete all vocabularies.
  $vocabularies = \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary')->loadMultiple();
  \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary')->delete($vocabularies);

  // Delete all media.
  $media = \Drupal::entityTypeManager()->getStorage('media')->loadMultiple();
  \Drupal::entityTypeManager()->getStorage('media')->delete($media);

  // Delete all files.
  $file = \Drupal::entityTypeManager()->getStorage('file')->loadMultiple();
  \Drupal::entityTypeManager()->getStorage('file')->delete($file);

  // Delete document fields.
  /* @var $entityFieldManager Drupal\Core\Entity\EntityFieldManager */
  $entityFieldManager = Drupal::service('entity_field.manager');
  $fields = $entityFieldManager->getFieldDefinitions('node', 'document');

  // Remove fields we need.
  unset($fields['nid']);
  unset($fields['uuid']);
  unset($fields['vid']);
  unset($fields['langcode']);
  unset($fields['type']);
  unset($fields['revision_timestamp']);
  unset($fields['revision_uid']);
  unset($fields['revision_log']);
  unset($fields['status']);
  unset($fields['uid']);
  unset($fields['title']);
  unset($fields['created']);
  unset($fields['changed']);
  unset($fields['promote']);
  unset($fields['sticky']);
  unset($fields['default_langcode']);
  unset($fields['revision_default']);
  unset($fields['revision_translation_affected']);
  unset($fields['base_author_hid']);
  unset($fields['base_files']);

  foreach ($fields as $field_name => $field_info) {
    FieldStorageConfig::loadByName('node', $field_name)->delete();
  }

  // Reset index.
  $config_path = drupal_get_path('module', 'docstore') . '/config/install/search_api.index.documents.yml';
  $data = Yaml::parseFile($config_path);
  \Drupal::configFactory()->getEditable('search_api.index.documents')->setData($data)->save(TRUE);

  // Create user if needed.
  if (!User::load(2)) {
    User::create([
      'uid' => 2,
      'status' => 1,
      'name' => 'Silk test',
      'type' => 'provider',
      'pass' => '',
      'prefix' => [
        'value' => 'silk_',
      ],
      'api_keys' => [
        'value' => 'abcd',
      ],
      'api_keys_read_only' => [
        'value' => 'xyzzy',
      ],
    ])->save();
  }

  // Invalidate caches.
  Cache::invalidateTags(['documents']);
  Cache::invalidateTags(['document_fields']);
}

/**
 * Convert query string to search api filter.
 */
function docstore_query_to_filters($filters) {
  $items = expand($filters);

  $root = [
    'id' => docstore_ROOT_ID,
    docstore_GROUP_KEY => [
      'conjunction' => 'AND',
    ],
  ];

  return buildTree($root, $items);
}

const docstore_VALUE_KEY = 'value';
const docstore_PATH_KEY = 'path';
const docstore_OPERATOR_KEY = 'operator';
const docstore_ROOT_ID = '@root';
const docstore_CONDITION_KEY = 'condition';
const docstore_MEMBER_KEY = 'memberOf';
const docstore_GROUP_KEY = 'group';

  /**
   * Expands any filter parameters using shorthand notation.
   *
   * @param array $original
   *   The unexpanded filter data.
   *
   * @return array
   *   The expanded filter data.
   */
  function expand(array $original) {
    $expanded = [];
    foreach ($original as $key => $item) {
      // Allow extreme shorthand filters, f.e. `?filter[promote]=1`.
      if (!is_array($item)) {
        $item = [
          docstore_VALUE_KEY => $item,
        ];
      }

      // Throw an exception if the query uses the reserved filter id for the
      // root group.
      if ($key == docstore_ROOT_ID) {
        $msg = sprintf("'%s' is a reserved filter id.", docstore_ROOT_ID);
        throw new \UnexpectedValueException($msg);
      }

      // Add a memberOf key to all items.
      if (isset($item[docstore_CONDITION_KEY][docstore_MEMBER_KEY])) {
        $item[docstore_MEMBER_KEY] = $item[docstore_CONDITION_KEY][docstore_MEMBER_KEY];
        unset($item[docstore_CONDITION_KEY][docstore_MEMBER_KEY]);
      }
      elseif (isset($item[docstore_GROUP_KEY][docstore_MEMBER_KEY])) {
        $item[docstore_MEMBER_KEY] = $item[docstore_GROUP_KEY][docstore_MEMBER_KEY];
        unset($item[docstore_GROUP_KEY][docstore_MEMBER_KEY]);
      }
      else {
        $item[docstore_MEMBER_KEY] = docstore_ROOT_ID;
      }

      // Add the filter id to all items.
      $item['id'] = $key;

      // Expands shorthand filters.
      $expanded[$key] = expandItem($key, $item);
    }

    return $expanded;
  }

  /**
   * Expands a filter item in case a shortcut was used.
   *
   * Possible cases for the conditions:
   *   1. filter[uuid][value]=1234.
   *   2. filter[0][condition][field]=uuid&filter[0][condition][value]=1234.
   *   3. filter[uuid][condition][value]=1234.
   *   4. filter[uuid][value]=1234&filter[uuid][group]=my_group.
   *
   * @param string $filter_index
   *   The index.
   * @param array $filter_item
   *   The raw filter item.
   *
   * @return array
   *   The expanded filter item.
   */
  function expandItem($filter_index, array $filter_item) {
    if (isset($filter_item[docstore_VALUE_KEY])) {
      if (!isset($filter_item[docstore_PATH_KEY])) {
        $filter_item[docstore_PATH_KEY] = $filter_index;
      }

      $filter_item = [
        docstore_CONDITION_KEY => $filter_item,
        docstore_MEMBER_KEY => $filter_item[docstore_MEMBER_KEY],
      ];
    }

    if (!isset($filter_item[docstore_CONDITION_KEY][docstore_OPERATOR_KEY])) {
      $filter_item[docstore_CONDITION_KEY][docstore_OPERATOR_KEY] = '=';
    }

    return $filter_item;
  }

  /**
   * Organizes the flat, normalized filter items into a tree structure.
   *
   * @param array $root
   *   The root of the tree to build.
   * @param array $items
   *   The normalized entity conditions and groups.
   *
   * @return \Drupal\jsonapi\Query\EntityConditionGroup
   *   The entity condition group
   */
  function buildTree(array $root, array $items) {
    $id = $root['id'];

    // Recursively build a tree of denormalized conditions and condition groups.
    $members = [];
    foreach ($items as $item) {
      if ($item[docstore_MEMBER_KEY] == $id) {
        if (isset($item[docstore_GROUP_KEY])) {
          array_push($members, buildTree($item, $items));
        }
        elseif (isset($item[docstore_CONDITION_KEY])) {
          array_push($members, $item);
        }
      }
    }

    $root[docstore_GROUP_KEY]['members'] = $members;

    // Denormalize the root into a condition group.
    return $root;
  }
